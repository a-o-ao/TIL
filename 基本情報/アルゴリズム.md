# アルゴリズム

- [木構造](#木構造)
- [探索アルゴリズム](#探索アルゴリズム)
- [整列アルゴリズム](#整列アルゴリズム)
- [プログラムの性質](#プログラムの性質)

## 木構造

ノード（節）と枝（エッジ）で構成され、階層的な関係を表すデータ構造

- 1つの根（ルート）ノードから始まり、子ノードへ枝分かれする
- 循環がない（閉じたループが存在しない）
- 各ノードは1つの親しか持たない（根を除く）

```
        A        ← 根（ルート）
       / \
      B   C      ← Aの子
     / \   \
    D   E   F    ← 葉（リーフ）
```
### 木構造の主な種類
| 種類名 | 特徴 |
| --- | --- |
| バランス木 | 深さが一定の木構造 |
| 二分木 | 子が最大で2つまでの木構造 |
| 完全二分木 | バランス木で子が必ず2つの木 |
| 探索木 | 効率よくデータを探せるように構造化された木構造 |
 
### 2分探索木

- 各ノードの左部分木の値 < 親ノードの値 < 右部分木の値（逆もOK）
- 探索・挿入・削除が平均 O(log n) の効率で行える（※平衡が保たれている場合）
- 再帰的な構造を持つ

```
      10
     /  \
    5    15
   / \     \
  2   7    20
```

- 「左の子 < 親 < 右の子 の関係」は孫まで引き継がれる。
```
      10
     /  \
    5    15
   / \    / \
  2   7  8  20   ←「8」は10より小さいのでNG
```

## 探索アルゴリズム

データの中から特定の値や条件に一致する要素を見つけるための手法や手順のこと

### 探索アルゴリズムの主な種類
| 種類名 | 特徴 |
| --- | --- |
| 線形探索 | - 先頭から順に全て調べる |
| 二分探索 | - ソート済みのデータに対して中間を分割しながら探索<br>- 平均計算量: O(log2 n) |
| ハッシュ探索 | - ハッシュ関数を使って直接位置を特定<br>- シノニム(衝突)が発生する場合がある |

### (log2 n)とは

- 2を何回かけたら n になるか

| 回数 | 値 |
| --- | --- |
| 2 | 4 |
| 3 | 8 |
| 4 | 16 |
| 5 | 32 |
| 6 | 64 |
| 7 | 128 |
| 8 | 256 |
| 9 | 512 |
| 10 | 1024 |
| 11 | 2048 |

問題：
2,000個の相異なる要素が、キーの昇順に整列された表がある。外部から入力したキーによってこの表を2分探索して、該当するキーの要素を取り出す。該当するキーが必ず表中にあることが分かっているとき、キーの比較回数は最大何回か。

回答：11回

## 整列アルゴリズム

データをある規則（昇順・降順など）に並べ替えるための手法

### 代表的な整列アルゴリズム一覧

| アルゴリズム名       | 特徴                                         | 時間計算量（平均） |
|--------------------|--------------------------------------------|------------------|
| **[バブルソート](#バブルソート)**       | 隣り合う要素を交換していく。単純だが遅い               | O(n²)            |
| **[選択ソート](#選択ソート)**         | 未整列の中から最小値（または最大値）を選んで、先頭と交換する   | O(n²)            |
| **[挿入ソート](#挿入ソート)**         | 左側の部分を常に「整列済み」として保ち、右から要素を1つずつ取り出して、適切な位置に“挿入”していく   | O(n²)            |
| **[シェルソート](#シェルソート)** | 離れた位置にある要素同士を比較しながら整列して、徐々に近づけていく |　O(n log n) or O(n²) | 
| **[クイックソート](#クイックソート)**     | 基準（ピボット）を1つ選び、それより小さい値と大きい値でデータを分けて再帰的に並べる  | O(n log n) |
| **[マージソート](#マージソート)** | 配列を半分に分割し要素1つになるまで分ける、小さく分けてからマージ（結合）していく。分割統治法 | O(n log n) |
| ヒープソート    | ヒープ構造を使って並べる。安定性なし。                  | O(n log n)       |
| 計数ソート    | 数の範囲が限られる場合に高速。比較を使わない。           | O(n)（条件あり） |


### バブルソート
[5, 3, 4, 1, 2]をソートする場合

-  1回目のループ（左から順に比較・入れ替え）
```
[5, 3, 4, 1, 2]
 ↑  ↑ → 5 > 3 なので入れ替え
[3, 5, 4, 1, 2]
    ↑  ↑ → 5 > 4 → 入れ替え
[3, 4, 5, 1, 2]
       ↑  ↑ → 5 > 1 → 入れ替え
[3, 4, 1, 5, 2]
           ↑  ↑ → 5 > 2 → 入れ替え
[3, 4, 1, 2, 5] ← 最大値「5」が最後に移動
```
- 繰り返す

### 挿入ソート

- 初期状態
```
[5 | 3, 4, 1, 2]
 ↑ 整列済み   ↑ 未整列
```

- 1回目：3 を整列済み部分に挿入
```
[3, 5 | 4, 1, 2]

比較：3 < 5 → 5 を右にずらす
```

- 2回目：4 を挿入
```
[3, 4, 5 | 1, 2]

比較：4 < 5 → 5 を右にずらす
比較：4 > 3 → ここに挿入！
```

- 3回目：1 を挿入
```
[1, 3, 4, 5 | 2]

比較：1 < 5 → ずらす
1 < 4 → ずらす
1 < 3 → ずらす
→ 1 を先頭に挿入！
```

- 繰り返す

### 選択ソート

- 1回目（先頭から最小値を探して、先頭と交換）
```
[1, 3, 4, 5, 2]
 ↑   ← 1 が確定
```

- 2回目（残りから最小値を探して、2番目と交換）
```
[1, 2, 4, 5, 3]
    ↑ ← 2 が確定
```

- 最大 n−1 回ループする

### シェルソート
[15, 9, 1, 18, 3, 6, 12, 21] をソートする場合

- 1回目：3個間隔をあけて比較して交換する
```
[15, 9, 1, 18, |3, 6, 12, 21]
 ↑              ↑
15と3を比較して交換

[3, 9, 1, 18, |15, 6, 12, 21]
    ↑              ↑
9と6を比較して交換
...最後まで
```

- 2回目：2間隔をあけて比較して交換する
```
[3, 6, 1, |18, 15, 9, |12, 21]
 ↑         ↑
3と18を比較して交換
    ↑          ↑
6と15を比較して交換
...最後まで
```

- 繰り返す

### クイックソート

- ステップ1：ピボットを選ぶ（例：最初の要素）
```
[15, 9, 1, 18, 3, 6, 12, 21] をソートする場合

ピボット = 15

→ 小さいグループ：[9, 1, 3, 6, 12]
→ 大きいグループ：[18, 21]

QuickSort([9, 1, 3, 6, 12]) + [15] + QuickSort([18, 21])
```

- ステップ2：小さいグループ：[9, 1, 3, 6, 12]
```
ピボット = 9

→ 小さい：[1, 3, 6]
→ 大きい：[12]

QuickSort([1, 3, 6]) + [9] + QuickSort([12])
```

- 上記を再帰的に繰り返す

```
再帰構造まとめ

QuickSort([15, 9, 1, 18, 3, 6, 12, 21])
├─ QuickSort([9, 1, 3, 6, 12])
│  ├─ QuickSort([1, 3, 6])
│  │  ├─ QuickSort([]) + [1] + QuickSort([3, 6])
│  │  │  ├─ QuickSort([]) + [3] + QuickSort([6])
│  └─ QuickSort([12])
├─ [15]
└─ QuickSort([18, 21])
```

### マージソート

- ステップ 1：分割をくり返す（半分に分ける）
```
[15, 9, 1, 18]        [3, 6, 12, 21]
  ↓                     ↓
[15, 9] [1, 18]      [3, 6] [12, 21]
  ↓       ↓           ↓       ↓
[15] [9] [1] [18]   [3] [6] [12] [21]
```

- ステップ 2：隣同士をマージ（小さい順に結合
```
[15] + [9]     → [9, 15]  
[1] + [18]     → [1, 18]  
[3] + [6]      → [3, 6]
[12] + [21]    → [12, 21]
```

- ステップ 3：さらにマージ
```
[9, 15] + [1, 18]     → 比較しながら → [1, 9, 15, 18]
 - 9 と 1 → 1
 - 9 と 18 → 9
 - 15 と 18 → 15

[3, 6] + [12, 21]     → 比較しながら → [3, 6, 12, 21]
```

- ステップ 4：最終マージ
```
[1, 9, 15, 18] + [3, 6, 12, 21]
↓
比較順にマージしていく：
 - 1 と 3 → 1
 - 9 と 3 → 3
 - 9 と 6 → 6
 - 9 と 12 → 9
 - 15 と 12 → 12
 - 15 と 21 → 15
 - 18 と 21 → 18
→ [1, 3, 6, 9, 12, 15, 18, 21]
```

## プログラムの性質

### 再配置可能（リロケータブル）

- メモリのどこに配置しても動作可能なプログラム
- ベースレジスタを使ったメモリ管理が主流であるためほとんどのCPUは再配置可能

### 再入可能（リエントラント）

- 割り込みや同時実行中でも安全に再び呼べる
- ローカル変数を使うことで再入可能となる（グローバル変数を使用しない）

``` java
// 例) 再入可能な関数
int add(int a, int b) {
    return a + b;  // ローカル変数しか使っておらず、再入可能
}

// 再入不可の例
int counter = 0;
void increment() {
    counter++;  // グローバル変数に依存
}
```

### 再使用可能（リユーザブル）

- １度ロードしたプログラムを何度も繰り返し利用できる

```javascript
// 再使用性が低い関数
function getUserNameFromTokyoOnly(user) {
    if (user.address.city === "Tokyo") {
        return user.name;
    }
    return null;
}

// 再使用可能な関数
function getUserNameIfInCity(user, city) {
    if (user.address.city === city) {
        return user.name;
    }
    return null;
}
```
- 逐次再使用可能 → 再入不可
- 同時再使用可能 → 再入可

### 再帰（リカーシブ）

- 自分自身を呼び出すことができる




